-- =====================================================
-- TABLA: kit
-- DESCRIPCIÓN: Composición de artículos tipo KIT
-- FECHA: 2025-01-03
-- =====================================================

DROP TABLE IF EXISTS kit;

CREATE TABLE kit (
    -- ----------------------------------------
    -- Identificador único
    -- ----------------------------------------
    id_kit INT UNSIGNED NOT NULL AUTO_INCREMENT,
    
    -- ----------------------------------------
    -- Campos específicos
    -- ----------------------------------------
    cantidad_kit INT UNSIGNED NOT NULL DEFAULT 1 COMMENT 'Cantidad del artículo componente en el kit',
    
    -- ----------------------------------------
    -- Claves foráneas
    -- ----------------------------------------
    id_articulo_maestro INT UNSIGNED NOT NULL COMMENT 'Artículo principal (el KIT)',
    id_articulo_componente INT UNSIGNED NOT NULL COMMENT 'Artículo que forma parte del kit',
    
    -- ----------------------------------------
    -- Campos de control (obligatorios)
    -- ----------------------------------------
    activo_kit TINYINT(1) NOT NULL DEFAULT 1,
    created_at_kit TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at_kit TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- ----------------------------------------
    -- Índices
    -- ----------------------------------------
    PRIMARY KEY (id_kit),
    UNIQUE KEY uk_kit_componente (id_articulo_maestro, id_articulo_componente),
    KEY idx_id_articulo_maestro (id_articulo_maestro),
    KEY idx_id_articulo_componente (id_articulo_componente),
    
    -- ----------------------------------------
    -- Foreign Keys
    -- ----------------------------------------
    CONSTRAINT fk_kit_articulo_maestro 
        FOREIGN KEY (id_articulo_maestro) 
        REFERENCES articulo(id_articulo) 
        ON DELETE CASCADE 
        ON UPDATE CASCADE,
        
    CONSTRAINT fk_kit_articulo_componente 
        FOREIGN KEY (id_articulo_componente) 
        REFERENCES articulo(id_articulo) 
        ON DELETE RESTRICT 
        ON UPDATE CASCADE
        
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_spanish_ci
COMMENT='Composición de artículos tipo KIT';

-- =====================================================
-- FIN DE LA TABLA DE KIT
-- =====================================================


-- =================================================================================
-- Validación adicional recomendada
-- Deberías agregar un TRIGGER para evitar que un artículo se referencie a sí mismo:
-- =================================================================================
DELIMITER $$

DROP TRIGGER IF EXISTS trg_kit_validar_autoreferencia$$

CREATE TRIGGER trg_kit_validar_autoreferencia
BEFORE INSERT ON kit
FOR EACH ROW
BEGIN
    -- Validar que el artículo maestro no se agregue como componente de sí mismo
    IF NEW.id_articulo_maestro = NEW.id_articulo_componente THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Un artículo no puede ser componente de sí mismo';
    END IF;
    
    -- Validar que el artículo maestro tenga es_kit_articulo = 1
    IF (SELECT es_kit_articulo FROM articulo WHERE id_articulo = NEW.id_articulo_maestro) = 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'El artículo maestro debe tener es_kit_articulo = 1';
    END IF;
    
    -- Validar que el componente NO sea también un kit (evitar kits recursivos)
    IF (SELECT es_kit_articulo FROM articulo WHERE id_articulo = NEW.id_articulo_componente) = 1 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Un componente no puede ser a su vez un KIT (evitar recursividad)';
    END IF;
END$$

DELIMITER ;


DELIMITER $$

-- =====================================================
-- TRIGGER: trg_kit_before_insert
-- DESCRIPCIÓN: Validaciones antes de insertar un componente en un kit
-- EVENTO: BEFORE INSERT
-- TABLA: kit
-- =====================================================

DROP TRIGGER IF EXISTS trg_kit_before_insert$$

CREATE TRIGGER trg_kit_before_insert
BEFORE INSERT ON kit
FOR EACH ROW
BEGIN
    DECLARE v_es_kit_maestro TINYINT(1);
    DECLARE v_es_kit_componente TINYINT(1);
    
    -- ----------------------------------------
    -- VALIDACIÓN 1: Auto-referencia
    -- ----------------------------------------
    IF NEW.id_articulo_maestro = NEW.id_articulo_componente THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Un artículo no puede ser componente de sí mismo';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 2: El maestro debe tener es_kit_articulo = 1
    -- ----------------------------------------
    SELECT es_kit_articulo INTO v_es_kit_maestro
    FROM articulo 
    WHERE id_articulo = NEW.id_articulo_maestro;
    
    IF v_es_kit_maestro = 0 OR v_es_kit_maestro IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: El artículo maestro debe tener es_kit_articulo = 1';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 3: El componente NO puede ser un KIT (evitar recursividad)
    -- ----------------------------------------
    SELECT es_kit_articulo INTO v_es_kit_componente
    FROM articulo 
    WHERE id_articulo = NEW.id_articulo_componente;
    
    IF v_es_kit_componente = 1 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Un componente no puede ser a su vez un KIT (evitar recursividad)';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 4: Cantidad debe ser positiva
    -- ----------------------------------------
    IF NEW.cantidad_kit <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: La cantidad debe ser mayor a 0';
    END IF;
END$$

-- =====================================================
-- TRIGGERS: kit
-- DESCRIPCIÓN: Validaciones para composición de kits
-- FECHA: 2025-01-03
-- =====================================================

DELIMITER $$

-- =====================================================
-- TRIGGER: trg_kit_before_insert
-- DESCRIPCIÓN: Validaciones antes de insertar un componente en un kit
-- EVENTO: BEFORE INSERT
-- TABLA: kit
-- =====================================================

DROP TRIGGER IF EXISTS trg_kit_before_insert$$

CREATE TRIGGER trg_kit_before_insert
BEFORE INSERT ON kit
FOR EACH ROW
BEGIN
    DECLARE v_es_kit_maestro TINYINT(1);
    DECLARE v_es_kit_componente TINYINT(1);
    
    -- ----------------------------------------
    -- VALIDACIÓN 1: Auto-referencia
    -- ----------------------------------------
    IF NEW.id_articulo_maestro = NEW.id_articulo_componente THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Un artículo no puede ser componente de sí mismo';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 2: El maestro debe tener es_kit_articulo = 1
    -- ----------------------------------------
    SELECT es_kit_articulo INTO v_es_kit_maestro
    FROM articulo 
    WHERE id_articulo = NEW.id_articulo_maestro;
    
    IF v_es_kit_maestro = 0 OR v_es_kit_maestro IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: El artículo maestro debe tener es_kit_articulo = 1';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 3: El componente NO puede ser un KIT (evitar recursividad)
    -- ----------------------------------------
    SELECT es_kit_articulo INTO v_es_kit_componente
    FROM articulo 
    WHERE id_articulo = NEW.id_articulo_componente;
    
    IF v_es_kit_componente = 1 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Un componente no puede ser a su vez un KIT (evitar recursividad)';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 4: Cantidad debe ser positiva
    -- ----------------------------------------
    IF NEW.cantidad_kit <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: La cantidad debe ser mayor a 0';
    END IF;
END$$

DELIMITER ;

-- =====================================================

DELIMITER $$

-- =====================================================
-- TRIGGER: trg_kit_before_update
-- DESCRIPCIÓN: Validaciones antes de actualizar un componente en un kit
-- EVENTO: BEFORE UPDATE
-- TABLA: kit
-- =====================================================

DROP TRIGGER IF EXISTS trg_kit_before_update$$

CREATE TRIGGER trg_kit_before_update
BEFORE UPDATE ON kit
FOR EACH ROW
BEGIN
    DECLARE v_es_kit_maestro TINYINT(1);
    DECLARE v_es_kit_componente TINYINT(1);
    
    -- ----------------------------------------
    -- VALIDACIÓN 1: Auto-referencia
    -- ----------------------------------------
    IF NEW.id_articulo_maestro = NEW.id_articulo_componente THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Un artículo no puede ser componente de sí mismo';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 2: El maestro debe tener es_kit_articulo = 1
    -- ----------------------------------------
    SELECT es_kit_articulo INTO v_es_kit_maestro
    FROM articulo 
    WHERE id_articulo = NEW.id_articulo_maestro;
    
    IF v_es_kit_maestro = 0 OR v_es_kit_maestro IS NULL THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: El artículo maestro debe tener es_kit_articulo = 1';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 3: El componente NO puede ser un KIT
    -- ----------------------------------------
    SELECT es_kit_articulo INTO v_es_kit_componente
    FROM articulo 
    WHERE id_articulo = NEW.id_articulo_componente;
    
    IF v_es_kit_componente = 1 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: Un componente no puede ser a su vez un KIT (evitar recursividad)';
    END IF;
    
    -- ----------------------------------------
    -- VALIDACIÓN 4: Cantidad debe ser positiva
    -- ----------------------------------------
    IF NEW.cantidad_kit <= 0 THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ERROR: La cantidad debe ser mayor a 0';
    END IF;
END$$

DELIMITER ;


-- =====================================================
-- VISTA: vista_kit_completa
-- DESCRIPCIÓN: Vista completa de kits con información de artículos
-- FECHA: 2025-01-03
-- 
-- DEPENDENCIAS:
--   - kit (tabla)
--   - articulo (tabla)
-- =====================================================

DROP VIEW IF EXISTS vista_kit_completa;

CREATE VIEW vista_kit_completa AS
SELECT 
    -- DATOS DE LA TABLA KIT
    k.id_kit,
    k.cantidad_kit,
    k.activo_kit,
    k.created_at_kit,
    k.updated_at_kit,
    
    -- ARTÍCULO MAESTRO (EL KIT)
    k.id_articulo_maestro,
    am.codigo_articulo AS codigo_articulo_maestro,
    am.nombre_articulo AS nombre_articulo_maestro,
    am.name_articulo AS name_articulo_maestro,
    am.precio_alquiler_articulo AS precio_articulo_maestro,
    am.es_kit_articulo AS es_kit_articulo_maestro,
    am.activo_articulo AS activo_articulo_maestro,
    
    -- ARTÍCULO COMPONENTE
    k.id_articulo_componente,
    ac.codigo_articulo AS codigo_articulo_componente,
    ac.nombre_articulo AS nombre_articulo_componente,
    ac.name_articulo AS name_articulo_componente,
    ac.precio_alquiler_articulo AS precio_articulo_componente,
    ac.es_kit_articulo AS es_kit_articulo_componente,
    ac.activo_articulo AS activo_articulo_componente,
    
    -- CAMPOS CALCULADOS
    (k.cantidad_kit * ac.precio_alquiler_articulo) AS subtotal_componente,
    
    -- SUBCONSULTA: Total componentes del kit maestro
    (SELECT COUNT(*) 
     FROM kit k2 
     WHERE k2.id_articulo_maestro = k.id_articulo_maestro 
       AND k2.activo_kit = 1) AS total_componentes_kit,
    
    -- SUBCONSULTA: Precio total del kit (suma de componentes)
    (SELECT SUM(k2.cantidad_kit * a2.precio_alquiler_articulo)
     FROM kit k2
     INNER JOIN articulo a2 ON k2.id_articulo_componente = a2.id_articulo
     WHERE k2.id_articulo_maestro = k.id_articulo_maestro
       AND k2.activo_kit = 1
       AND a2.activo_articulo = 1) AS precio_total_kit

FROM kit k
INNER JOIN articulo am ON k.id_articulo_maestro = am.id_articulo
INNER JOIN articulo ac ON k.id_articulo_componente = ac.id_articulo;